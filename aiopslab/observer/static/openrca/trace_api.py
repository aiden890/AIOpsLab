# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

"""OpenRCA Trace Observer API - reads trace data from CSV files."""

import logging
from pathlib import Path
from datetime import datetime
from typing import Optional
import pandas as pd

from aiopslab.observer.static.base import StaticObserverBase

logger = logging.getLogger(__name__)


class OpenRCATraceAPI(StaticObserverBase):
    """
    Observer API for OpenRCA trace telemetry.

    Reads trace data from CSV files generated by the static replayer.
    Supports time-windowed queries and filtering by service (cmdb_id).
    """

    def __init__(self, output_path: Path):
        """
        Initialize OpenRCA Trace API.

        Args:
            output_path: Path to telemetry output directory containing trace.csv
        """
        super().__init__(output_path)
        self.telemetry_type = 'trace'

        # Expected schema for OpenRCA trace data
        self.expected_columns = [
            'timestamp', 'cmdb_id', 'parent_id',
            'span_id', 'trace_id', 'duration'
        ]

    def get_csv_path(self) -> Path:
        """Return path to trace.csv file."""
        return self.output_path / 'trace.csv'

    def extract_data(self, start_time: datetime, end_time: datetime, **filters) -> pd.DataFrame:
        """
        Extract trace data within time window with optional filters.

        Args:
            start_time: Start of time window
            end_time: End of time window
            **filters: Optional filters (cmdb_id, trace_id)

        Returns:
            DataFrame with filtered trace data
        """
        return self.query_traces(
            start_time=start_time,
            end_time=end_time,
            cmdb_id=filters.get('cmdb_id'),
            trace_id=filters.get('trace_id')
        )

    def query_traces(
        self,
        start_time: datetime,
        end_time: datetime,
        cmdb_id: Optional[str] = None,
        trace_id: Optional[str] = None
    ) -> pd.DataFrame:
        """
        Query trace data within a time window with optional filters.

        Args:
            start_time: Start of time window
            end_time: End of time window
            cmdb_id: Optional filter for specific service/component
            trace_id: Optional filter for specific trace ID

        Returns:
            DataFrame with trace spans matching the query

        Raises:
            ValueError: If start_time > end_time
        """
        # Validate time range
        if start_time > end_time:
            raise ValueError(f"start_time ({start_time}) must be <= end_time ({end_time})")

        logger.info(f"Querying traces: {start_time} to {end_time}")
        if cmdb_id:
            logger.info(f"  Filter: cmdb_id={cmdb_id}")
        if trace_id:
            logger.info(f"  Filter: trace_id={trace_id}")

        # Read CSV with time filtering
        df = self._read_csv_with_time_filter(start_time, end_time)

        if df.empty:
            logger.info("No traces found in time window")
            return df

        # Apply additional filters
        if cmdb_id:
            df = df[df['cmdb_id'] == cmdb_id]

        if trace_id:
            df = df[df['trace_id'] == trace_id]

        logger.info(f"Found {len(df)} trace spans")
        return df

    def get_trace_by_id(self, trace_id: str) -> pd.DataFrame:
        """
        Get all spans for a specific trace ID.

        Args:
            trace_id: The trace ID to retrieve

        Returns:
            DataFrame with all spans for this trace
        """
        csv_path = self.get_csv_path()

        if not csv_path.exists():
            logger.warning(f"Trace CSV not found: {csv_path}")
            return pd.DataFrame(columns=self.expected_columns + ['datetime'])

        try:
            # Read entire CSV and filter by trace_id
            df = pd.read_csv(csv_path)

            if 'trace_id' not in df.columns:
                logger.error(f"trace_id column not found in {csv_path}")
                return pd.DataFrame(columns=self.expected_columns + ['datetime'])

            # Filter by trace_id
            df = df[df['trace_id'] == trace_id]

            # Add datetime column
            if 'timestamp' in df.columns:
                df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')

            logger.info(f"Found {len(df)} spans for trace {trace_id}")
            return df

        except Exception as e:
            logger.error(f"Error reading trace CSV: {e}", exc_info=True)
            return pd.DataFrame(columns=self.expected_columns + ['datetime'])

    def get_services(self) -> list[str]:
        """
        Get list of all services (cmdb_ids) in the trace data.

        Returns:
            List of unique service names
        """
        csv_path = self.get_csv_path()

        if not csv_path.exists():
            logger.warning(f"Trace CSV not found: {csv_path}")
            return []

        try:
            # Read cmdb_id column only
            df = pd.read_csv(csv_path, usecols=['cmdb_id'])
            services = df['cmdb_id'].unique().tolist()
            logger.info(f"Found {len(services)} unique services in traces")
            return services
        except Exception as e:
            logger.error(f"Error reading services from trace CSV: {e}")
            return []
